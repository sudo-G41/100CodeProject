# Jungol[문제이름](http://www.jungol.co.kr/bbs/board.php?bo_table=pbank&code=2468&sca=4010)
## 문제
    KOI 보안회사에서는 자동으로 비밀번호를 만드는 시스템을 연구하고 있다. 
    주어진 하나의 양의 정수에 대하여 다음의 원칙에 따라 두 수를 만들어 비밀번호를 정하려고 한다.

    하나의 주어진 양의 정수 A에 대하여 비밀번호를 위한 두 수를 만드는 방법은 다음과 같다.
    
    1. A의 이진수 표현에서 나오는 1의 개수 x를 찾는다.

    2. A보다 작은수 중에서 그 수의 이진수 표현에서 1의 개수가 x와 같고 A에 가장 가까운 수를 하나 찾는다.

    3. A보다 큰수 중에서 그 수의 이진수 표현에서 1의 개수가 x와 같고 A에 가장 가까운 수를 하나 찾는다.

    예를 들어, 주어진 수 A가 43이면, 이 수의 이진수 표현은 101011(2)이다. 이 이진수는 1의 개수가 4이다. 
    그러므로 43보다 작고 43에 가장 가까우며 이진수 표현에서 1의 개수가 4인 수는 39=100111(2)이다.
    또한 43보다 크고 43에 가장 가까우며 이진수 표현에서 1의 개수가 4인 수는 45=101101(2)이다.
    이 두 수를 찾아 출력하는 프로그램을 작성하시오.

## 입력형식 
    입력의 첫 번째 줄에는 하나의 양의 정수 가 주어진다.
    단 1≤A≤1018이다.

## 출력형식
    주어진 수 보다 작은 수 중에서 이진수의 1의 개수가 같으며 가장 가까운 수와, 
    주어진 수 보다 큰 수 중에서 이진수의 1의 개수가 같으며 가장 가까운 수를 한 줄에 빈칸을 사이에 두고 출력한다.
    만약 그러한 수가 존재하지 않으면 그 수에 대해서는 0을 출력한다.

## 내 풀이
 큰수와 작은수를 나누어서 설명해보자.

 우선 큰 수는 처음으로 1이 나오기 시작한 뒤 그 다음의 0이 나오는 위치와 그 사이이의 1의 개수가 핵심인 문제이다. 오른쪽(1의 자리수)부터 0이 나오다가 처음으로 1이 나오고 그 다음의 0의 위치에(1의자리수가 1이라면 처음부터 1이므로 처음에 나오는 0을 말한다.)1을 넣어주고 그 전까지 즉 1이 끝나는 위치까지의 갯수만큼 쉬프트를 진해애준다. 그 후 1의 개수-1 만큼 1을 뒤에서부터 넣어주면 되는데 이는 1의 개수를 $n$이라 했을때 $2^n-1$을 해주게 되면 $n-1$개의 1을 가진 숫자가 되므로 $2^n-1$를 더해주게 되면 된다.

 작은 수는 좀 특이한 방식으로 풀었다.

 우선 입력받은 수 A가 연속된 1로만 이루어진 수라면 즉 $2^n-1$에 해당하면 작지만 1의 개수가 같은 숫자는 존제할 수 없으므로 0을 리턴해주면 된다.
 
 이는 약간의 응용인데 $2^n$인지 확인할 때 사용하는 방법으로 자연수 x가 주어졌을 때 x와 x-1을 and했을경우 x가 $2^n$이면 0이 출력 되는데 그 이유는 $2^n$는 1하나에 나머지는 0의 형태를 띄고 거기서 1을 뺀 숫자는 $2^n$의 1 부분에는 0, 그 아랫자리 숫자는 1인 형태를 띄우고 있어서 비교했을때 둘중 하나는 0이 되므로 전체가 0이 될 수 밖에 없다.
 
 이 점을 생각해보면 1이 연속된 수에 1을 더하면 $2^n$을 띄운단 말이고 이는 위에서 말한 방식이 통한다는 이야기가 되므로 그것을 통해 걸러 낼 수 있다.

 그리고 연속된 1로 이루어진 숫자가 아니라면 큰수와는 반대로 처음 0이 나오기 시작하고 그 위에 처음 나온 1을 찾아야 한다.
 그 뒤 처음 나온 1과 그 전의 0과 위치를 바꿔 주고 그 뒤 아래 있던 1들을 방금 바꾼 1뒤에 늘어놓아주면 되는데 난 좀 특이하게 찾아서 풀게 되었다. 나처럼 풀지말고 그냥 찾아서 넣어라 그게 정신건강에도 좋고 편하다.

## 구현([전체 코드 파일](/jungol/2468%3A%EB%B9%84%EB%B0%80%EB%B2%88%ED%98%B8/))
``` cpp
long long up(long long A){
	long long a = A;
	long long shift, add;
	shift = 0;
	add = 0;
	bool flag = true;
	while(true){
		if(add){
			if(!(a&1))
				return ((a+1)<<shift)+add-1;
			else
				add = add<<1;
		}
		else{
			add = a&1;
		}
		a = a>>1;
		shift+=1;
	}
	return -1;
}
long long down(long long A){
	if(!((A+1)&A))
		return 0;
	long long a = (A+1)^A;
	long long b = A-(a>>1);
	long long c = ((A^(A-a))+1)>>2;
	long long d = (a+1)>>1;
	return b-(c/d);
}
```

## 잡담
 아 작은수 저거 사실 프로그레머스의 2개 이하로 다른 비트 찾기에서 응용한건데 사실 큰수도 그렇게 찾고 싶었다...

 왜 프로그래머스꺼는 큰수 찾는거여서 큰수 찾기에 써야 되는게 맞을것 같은데 오히려 작은수에 적용되는게 신기하기도 하고 미칠것 같기도 하고 모르겠다... 그리고 여기서는 속도 개망했네 프로그래머스는 속도 미친듯이 빨랐는데... 뭐... 비트연산이 느리기도 하고 bigO가 다르니... 프로그래머스는 m*nlogn문제를 n으로 풀었지만 여긴 좀 다르니 마음아프구만....

 비트써서 풀었으니 이제 메타비트 령사 해도 되것지...? ㅋㅋㅋㅋㅋ