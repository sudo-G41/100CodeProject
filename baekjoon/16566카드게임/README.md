# 백준[16566](https://www.acmicpc.net/problem/16566)번
## 문제

철수와 민수는 카드 게임을 즐겨한다. 이 카드 게임의 규칙은 다음과 같다.

    N개의 빨간색 카드가 있다. 각각의 카드는 순서대로 1부터 N까지 번호가 매겨져 있다. 이 중에서 M개의 카드를 고른다.
    N개의 파란색 카드가 있다. 각각의 카드는 순서대로 1부터 N까지 번호가 매겨져 있다. 이 중에서 빨간색에서 고른 번호와 같은 파란색 카드 M개를 고른다.
    철수는 빨간색 카드를 가지고 민수는 파란색 카드를 가진다.
    철수와 민수는 고른 카드 중에 1장을 뒤집어진 상태로 낸다. 그리고 카드를 다시 뒤집어서 번호가 큰 사람이 이긴다. 이 동작을 K번 해서 더 많이 이긴 사람이 최종적으로 승리한다. 한 번 낸 카드는 반드시 버려야 한다.

철수는 뛰어난 마술사이기 때문에 본인이 낼 카드를 마음대로 조작할 수 있다. 즉, 카드를 버리고 민수 몰래 다시 들고 온다거나 민수한테 없는 카드를 내기도 한다.

민수는 뛰어난 심리학자이기 때문에 철수가 낼 카드를 알아낼 수 있다. 그래서 민수는 철수가 낼 카드보다 큰 카드가 있다면 그 카드들 중 가장 작은 카드를 내기로 했다.

K번 동안 철수가 낼 카드가 입력으로 주어진다. 그렇다면 민수가 어떤 카드를 낼지 출력하라. 단, 민수가 카드를 내지 못하는 경우는 없다고 가정한다.
## 입력
첫째 줄에 세 개의 자연수 N, M, K가 주어진다. (1 ≤ M ≤ N ≤ 4,000,000, 1 ≤ K ≤ min(M, 10,000))

다음 줄에 카드의 번호를 나타내는 M개의 자연수가 주어진다. 각각의 수들은 1 이상이고 N 이하이며 서로 다르다.

다음 줄에 K개의 자연수가 주어진다. i번째 수는 철수가 i번째로 내는 카드의 번호이다. 철수가 내는 카드 역시 1 이상 N 이하이다.
## 출력
K줄에 걸쳐서 수를 출력한다. i번째 줄에는 민수가 i번째로 낼 카드의 번호가 출력되어야 한다.
## 내 풀이
union-find에서 find의 개념을 빌려 풀어봤다.

인덱스+1의 값을 가지는 리스트를 하나 준비한다.
``` python
deck = [i+1 for i in range(N+1)]
```

이 리스트는 union-find에서 부모노드를 찾을 때 사용 되는 리스트처럼 어떠한 카드에 대하여 그 카드보다 크거나 같은 민수의 카드를 부모노드로 가지게 하여 빠른 속도로 민수의 카드를 찾게 하는 것이 목적인 리스트다.

그러므로 민수가 뽑은 카드들은 자기 자신을 값으로 가지게 해주어야 한다.
``` python
for card in minsu_card:
    deck[card] = card
```
여기까지 오면 준비는 끝났다. 이제 철수가 뽑은 카드보다 크면서 그 중 가장 작은 카드를 선택해야 하는데 그때 가장 이상적인 카드는 철수카드+1이므로 철수카드+1의 민수카드를 저 리스트에서 찾아주기만 하면 해당 카드를 찾을 수 있다.  
다만 해당 카드는 쓰면 버려야 하므로 해당 카드를 사용하면 그 카드의 값을 +1증가시키어 다음을 가리키게 하여 더이상 쓸 수 없다고 표시를 해주어야 한다.

## 구현([전체 코드 파일](./p.py))
``` python
def solution():
    def find(d,c):
        if d[c] == c:
            return c
        else:
            d[c] = find(d, d[c])
            return d[c]

    N,M,K = map(int, input().strip().split())
    deck = [i+1 for i in range(N+1)]
    for card in map(int, input().strip().split()):
        deck[card] = card

    print(deck)

    for fraud in map(int, input().strip().split()):
        card = find(deck, fraud+1)
        print(card)
        deck[card] = card+1
```

## 잡담
이 문제를 풀기까지의 과정을 말하자면

처음에는 철수가 내는 카드에 대응하여 이분탐색으로 민수의 카드를 찾는 방식으로 하니 시간초과가 났다.

철수의 카드 M개에 대응하여 민수의 카드 M개중 이분탐색을 이용하여 찾은 한개의 카드(log M)이니 시간복잡도가 M log M인거 같은데 이게 시간초과라니...

그러다 재료구조를 보니 부분 집합이라 젹혀있는걸 보고 부분집합 하면 union-find지 이러고 있는데 생각해보니 저기서 find만 가져다가 잘 써보면 약 3M정도면 이라는 생각이 들기 시작했고 해보니 파이썬은 통과 하더라.... C++은 왜 메모리 초과지...?