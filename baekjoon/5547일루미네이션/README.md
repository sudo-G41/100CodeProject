# 백준[번호](https://www.acmicpc.net/problem/5547)번
## 문제
 부유한 집안의 상속자 상근이네 집은 그림과 같이 1미터의 정육각형이 붙어있는 상태이다. 크리스마스가 다가오기 때문에, 여자친구에게 잘 보이기 위해 상근이는 건물의 벽면을 조명으로 장식하려고 한다. 외부에 보이지 않는 부분에 조명을 장식하는 것은 낭비라고 생각했기 때문에, 밖에서 보이는 부분만 장식하려고 한다.  
 ![그림1](https://www.acmicpc.net/upload/images/building.png)  
 위의 그림은 상공에서 본 상근이네 집의 건물 배치이다. 정육각형 안의 숫자는 좌표를 나타낸다. 여기서 회색 정육각형은 건물의 위치이고, 흰색은 건물이 없는 곳이다. 위에서 붉은 색 선으로 표시된 부분이 밖에서 보이는 벽이고, 이 벽에 조명을 장식할 것이다. 벽의 총 길이는 64미터이다.

 상근이네 집의 건물 위치 지도가 주어졌을 때, 조명을 장식할 벽면의 길이의 합을 구하는 프로그램을 작성하시오. 지도의 바깥은 자유롭게 왕래 할 수 있는 곳이고, 인접한 건물 사이는 통과할 수 없다.

## 입력
 첫째 줄에 두 개의 정수 W와 H가 주어진다. (1 ≤ W, H ≤ 100) 다음 H줄에는 상근이네 집의 건물 배치가 주어진다. i+1줄에는 W개의 정수가 공백으로 구분되어 있다. j번째 (1 ≤ j ≤ w) 정수의 좌표는 (j, i)이며, 건물이 있을 때는 1이고, 없을 때는 0이다. 주어지는 입력에는 건물이 적어도 하나 있다.

지도는 다음과 같은 규칙에 의해 만들어졌다.

    지도의 가장 왼쪽 위에 있는 정육각형의 좌표는 (1,1)이다.
    (x,y)의 오른족에 있는 정육각형의 좌표는 (x+1,y)이다.
    y가 홀수 일 때, 아래쪽에 있는 정육각형의 좌표는 (x,y+1)이다.
    y가 짝수 일 때, 오른쪽 아래에 있는 정육각형의 좌표는 (x,y+1)이다.

## 출력
 조명을 장식하는 벽면의 길이의 합을 출력한다.

## 내 풀이
 y축이 짝수일 경우 근접해 있는 노드와 짝수일 경우 근접해 있는 노드가 다르다. 그래서 이동 경로에 대한 배열을 우선 준비해둔다.
 이 문제는 건물을 기준으로 생각하면 건물에 갇힌 안쪽 벽을 걸러낼 방법이 있긴 하겠지만 복잡해진다 아니면 없거나...  
 그래서 패딩을 1줘서 아예 밖에서 걷기 시작하다가 건물을 만나면 그곳이 외벽이 되는 점을 이용하여 벽의 개수를 세는 방식으로 풀었다.

## 구현([전체 코드 파일](/baekjoon/폴더이름/코드파일))
``` python
def solution():
    w, h = map(int, input().strip().split())
    place = [[0 for _ in range(w+2)]]
    for _ in range(h):
        place.append([0]+list(map(int, input().strip().split()))+[0])
    place.append([0 for _ in range(w+2)])
    building = [[True for _ in range(w+2)] for _ in range(h+2)]

    q=[[0,0]]
    check_x = [
        [-1, 0, 1, 0, -1, -1],
        [0, 1, 1, 1, 0, -1]
    ]
    check_y = [-1, -1, +0, +1, +1, +0]
    wall = 0
    while q:
        _x, _y = q.pop(0)
        for idx in range(len(check_y)):
            x, y = _x+check_x[_y%2][idx], _y+check_y[idx]
            if 0>x or x>len(building[0])-1:
                continue
            if 0>y or y>len(building)-1:
                continue
            if place[y][x] == 1:
                wall += 1
            elif building[y][x]:
                q.append([x,y])
                building[y][x] = False

    return wall
```

## 잡담
 