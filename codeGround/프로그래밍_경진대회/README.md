# 삼성 코드그라운드

## 문제

삼성 프로그래밍 경진대회는 권위 있는 대회이다. 대회는 여러 라운드를 통해서 진행되며, 모든 라운드에 총 N명의 응시자가 있다.  
각 라운드 별로 1등은 N점, 2등은 N−1점 순으로 순차적으로 점수를 얻게 되고 뒤에서 2등은 2점, 뒤에서 1등은 1점을 얻게 된다.  
그리고 각 라운드 별로 동점자는 없으며, 각 라운드 마다 받은 점수의 합이 제일 높은 사람이 우승하게 된다.  
마지막 라운드 직전까지의 점수 합이 주어졌을 때, 우승할 가능성이 있는 응시자의 수를 구하는 프로그램을 작성하시오.
(SCPC 실제 대회 규칙과는 관련이 없습니다.)


- 제한시간: 전체 테스트 케이스는 5개 이하이며, 전체 수행 시간은 1초 이내. (Java 2초 이내)

        제한 시간을 초과하면 제출한 소스코드의 프로그램이 즉시 종료되며, 그때까지 수행한 결과에서 테스트 케이스를 1개 그룹 이상 통과하였더라도 점수는 0점이 됩니다.
        그러나, 제한 시간을 초과하더라도 테스트 케이스를 1개 그룹 이상 통과하였다면 '부분 점수(0< 점수< 만점)'를 받을 수 있으며, 이를 위해서는, C / C++ 에서 "printf 함수" 사용할 경우, 프로그램 시작부분에서 "setbuf(stdout, NULL);"를 한번만 사용하십시오.
        C++에서는 "setbuf(stdout, NULL);"와 "printf 함수" 대신 "cout"를 사용하고, Java에서는 "System.out.printIn"을 사용하시면, 제한 시간을 초과하더라도 '부분 점수'를 받을 수 있습니다.                                     ※ 언어별 기본 제공 소스코드 내용 참고
        만약, 제한 시간을 초과하지 않았는데도 '부분 점수'를 받았다면, 일부 테스트 케이스를 통과하지 못한 경우 입니다.

- 메모리 사용 제한 : heap, global, static 총계 256MB, stack 1MB

## 메모리 사용 제한

heap, global, static (총계) : 256MB
stack : 1MB

## 입력

입력 파일에는 여러 테스트 케이스가 포함될 수 있다.
파일의 첫째 줄에 케이스의 개수 T
가 주어지고,
후 차례로 T개 테스트 케이스가 주어진다. (1≤T≤5)
각각의 테스트 케이스의 첫 줄에는 응시자의 수 N 이 주어지며 ( 1≤N≤300,000 ),
다음  N 개의 줄에는 각 응시자가 마지막 라운드 전까지 받은 점수의 합을 나타내는 N

개의 자연수가 한 줄에 하나씩 주어진다.
(여기서 점수 합은 2,000,000을 넘지 않는 음이 아닌 정수이다.)

## 출력

각 테스트 케이스의 답을 순서대로 표준출력으로 출력하여야 하며,  
각 테스트 케이스마다 첫 줄에 “Case #T”를 출력하여야 한다.  
이때 T 는 케이스의 번호이다.  
각 케이스에 대해서 우승할 가능성이 있는 응시자의 수를 출력한다.

## 풀이

현재 가장 높은 점수인 응시자가 $N$점을 얻으면 그 응시자 밖에 우승이 불가능하다.  
그러니까 여기서 원하는건 가장 많은 경우의 수 일 것이다.  
그럼 우승을 위한 최소 점수는 몇일까? 가장 높은 점수를 가지고 있는 응시자가 1을 받으면 그게 최소가 될 것인가? 예를 들어 점수가 각각 1번 응시자가 3, 2번 응시자가 3, 3번 응시자가 2을 받았다고 해보자 3 3 2로 1번이 1을 받는다면 2번이 2 이상을 받게 되어 1번이 얻은 점수인 4점으로는 우승이 절대 불가능하다.  
즉 최대 점수 -> 최소 점수에게 각 $1$ -> $N$의 점수를 더하고 그 중 최대값이 우승의 최소 값이 된다.  
이 상태에서 모든 응시자$i$가 $N$을 받았고 최소 점수 응시자가 $N-i$점을 받고 나머지 응시자는 위 조건인 최대 -> 최소 + $1$ -> $N$에 해당하는 점수를 받게 되면 최소 점수만 우승이 가능하므로 모든 응시자의 $N$를 더한 값이 최소 점수 이상이 되면 우승이 가능하다.


## 구현([전체 코드 파일](/baekjoon/1038/c.py))
``` c++
int main(int argc, char** argv)
{
	int T, test_case;
	cin >> T;
	for(test_case = 0; test_case  < T; test_case++)
	{
		Answer = 0;
		int N;
        cin >> N;
        multiset<int> s;
        for(int idx = 0; idx < N; idx++){
            int tmp;
            cin >> tmp;
            s.insert(tmp);
        }
        int max = 0;
        int idx = 0;
        for(auto it = s.begin(); it != s.end(); it++){
            if(max < *it + N - idx){
                max = *it + N - idx;
            }
            idx++;
        }
        for(auto it = s.begin(); it != s.end(); it++){
            if(max <= *it + N){
                Answer++;
            }
        }
		cout << "Case #" << test_case+1 << endl;
		cout << Answer << endl;
	}
	return 0;
}
```

## 잡담
코드그라운드 진짜 오랜만이다. 아... 아아.... 아.