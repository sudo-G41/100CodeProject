# 백준[1419](https://www.acmicpc.net/problem/1419)번
## 문제
 첫 항이 x이고 공차가 d인 등차수열의 첫 k개의 항은 x, x+d, x+2d, ..., x+(k-1)d이다. x와 d가 자연수인 등차수열의 첫 k개의 항의 합으로 나타낼 수 있는 수 중에서, l 이상이고 r 이하인 수가 몇 개인지 구하는 프로그램을 작성하시오.

## 입력
 자연수 l, r, k가 순서대로 한 줄에 하나씩 주어진다. (1 ≤ l ≤ r ≤ 1,000,000,000, 2 ≤ k ≤ 5)

## 출력
 첫째 줄에 조건을 만족하는 수의 개수를 출력한다.

## 내 풀이
 일단 이거 풀이가 참 다양하다. 다른 사람들 코드 보는데 다 다르다... 그중 내가 생각한..? 풀이과정을 이야기 해보겠다....
 1. 우선 k가 2 &le; k &le; 5이므로 2부터 5까지 일단 나열해 본다.
 1. k=2일 경우를 나열해보자.<br>
 1+2=3, 1+3=4, 1+5=6... 3이상의 모든 수를 표현할 수 있으므로 r이 3미만일 경우 만족하는 수가 없다.<br>
 r이 3이상일 경우 l이 3미만일 경우 l로 3으로 바꾸고 l이 3이상일 경우 그대로 둔 상태에서 r-l+1하면 만족하는 갯수가 나온다.
 1. k=3일 경우를 나열해보자.<br>
 1+2+3=6, 1+3+5=2+3+4=9, 1+4+7=2+4+6=3+4+5=12... 혹시 규칙이 보이는가?<br>
 최소값이 6이고 3씩 증가하는 것이? 그리고 x가 1식 증가 하더라도 그 값이 x가 1인 경우로 표현이 가능한 것이?<br>
 왜 이렇게 되냐고? 나도 모른다. 다만 예상을 조금 해보자면 (x)+(x+d)+(x+2d) = 3x+3d = 3(x+d)라서 결국 3의 배수끼리의 놀이가 되는 것이 아닐까 조심스럽게 예상해본다.
 1. k=4일 경우를 나열해보자.<br>
 1+2+3+4=10, 1+3+5+7=16, 1+4+7+10=22, 1+5+9+13=28<br>
 2+3+4+5=14, 2+4+6+8=20, 2+5+8+11=26<br>
 3+4+5+6=18, 3+5+7+9=24, 3+6+9+12=30<br>
 4+5+6+7=22, 4+6+8+10=28<br>
 일단 여기도 규칙이 원가 보인다.

        1. x가 같고 d가 다를 경우 d가 1씩 증가하면 6씩 늘어난다.
        2. x가 3차이 나면 x-1에 d가 서로 다른 어딘가에 나온다.
        3. d가 같고 x가 1씩 차이나면 서로 4씩 차이가 난다.
        그러므로 x가 1,2,3경우만 따져보면 되는 것으로 추정된다.

    이러한 규칙에 따라 x가 1,2,3인 경우의 최솟값을 구하고 그 이후의 갯수를 파악하기만 하면 구해진다는 이야기가 되며 l이 10미만이면 가장 최소의 기준을 못미치므로 0개 10 이상이라면 각각의 갯수를 구하고 더하면 될것 같다.
    x가 같고 d가 다를 경우 d가 1씩 증가하면 6씩 늘어나는 이 부분과 d가 같고 x가 1씩 차이나면 서로 4씩 차이난느 부분에 대해서는 x+(x+d)+(x+2d)+(x+3d) = 4x+6d이므로 d가 1 증가하면 6씩 차이나고 x가 1 증가하면 4가 차이나게 된다.<br>
    x가 3차이 나면 x-1에 d가 서로 다른 어딘가 나오는 부분은 나도 잘 설명 못하겠다... 나도 잘 모르겠기 때문이다. 뭔가 4와 6의 공배수? 공약수 문제인거 같긴 한데 맞는지 모르니 모르겠다...
 1. k=5일 경우를 나열해보자.<br>
 1+2+3+4+5=15, 1+3+5+7+9=25
 2+3+4+5+6=20, 2+4+6+8+10=30<br>
 3+4+5+6+7=25<br>
 뭔가 보인다. 일단 수식으로 써보자. x+(x+d)+(x+2d)+(x+3d)+(x+4d) = 5x+10d = 5(x+2d) 보이는가? k=3일떄와 시슷한 수식을? 5씩 증가한다..! 실재 나열한 수들도 5씩 증가한다.

 이런식으로 일일히 해보면서 규칙 찾고 풀었다.. ㅎㅎ...

## 구현([전체 코드 파일](/baekjoon/1419등차수열의합/c.py))
``` python
def A(l:int,r:int,k:int)->None:
        if k==2:
                if r<3:
                        print(0)
                else:
                        l = 3 if l<3 else l
                        print(r-l+1)
        elif k==3:
                #L[l mod 3][counting]
                L = [[0,1,1],[0,0,0],[0,0,1]]
                if r<6:
                        print(0)
                else:
                        l = 6 if l<6 else l
                        tmp = (r-l+1)
                        print(tmp//3 + L[l%3][tmp%3])
        elif k==4:
                if r<10:
                        print(0)
                else:
                        l = 10 if l<10 else l
                        r1 = (r-4)//6
                        r2 = (r-8)//6
                        r3 = (r-12)//6 if r>17 else 0
                        l1 = (l-4)//6 - (1 if (l-4)%6==0 else 0)
                        l2 = (l-8)//6 - (1 if (l-8)%6==0 else 0)
                        l3 = (l-12)//6 - (1 if (l-12)%6==0 else 0) if l>17 else 0
                        print(r1+r2+r3-l1-l2-l3)
        elif k==5:
                if r<15:
                        print(0)
                else:
                        l = 15 if l<15 else l
                        tmpR = r//5
                        tmpL = l//5
                        print(tmpR-tmpL+(1 if l%5==0 else 0))
```

## 잡담
아 k=4이거 하느라 고생했다... 따로 따로 생각해야 하니까.... 그런대 다른 사람 풀이 보면 그럴 필요 없더라... ㅎㅎ... 아.....<br>
그리고 이거 적으면서 든 생각인데 처음부터 저거 저 nx+md이런식으로 풀어 썻으면 좀더 빨리 편하게 풀었던가 나닐까 생각이 든다... ㅎㅎ......하....