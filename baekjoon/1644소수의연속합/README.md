# 백준[11660](https://www.acmicpc.net/problem/1644)번
## 문제
하나 이상의 연속된 소수의 합으로 나타낼 수 있는 자연수들이 있다. 몇 가지 자연수의 예를 들어 보면 다음과 같다.

* 3 : 3 (한 가지)
* 41 : 2+3+5+7+11+13 = 11+13+17 = 41 (세 가지)
* 53 : 5+7+11+13+17 = 53 (두 가지)

하지만 연속된 소수의 합으로 나타낼 수 없는 자연수들도 있는데, 20이 그 예이다. 7+13을 계산하면 20이 되기는 하나 7과 13이 연속이 아니기에 적합한 표현이 아니다. 또한 한 소수는 반드시 한 번만 덧셈에 사용될 수 있기 때문에, 3+5+5+7과 같은 표현도 적합하지 않다.

자연수가 주어졌을 때, 이 자연수를 연속된 소수의 합으로 나타낼 수 있는 경우의 수를 구하는 프로그램을 작성하시오.


## 입력
 첫째 줄에 자연수 N이 주어진다. (1 ≤ N ≤ 4,000,000)

## 출력
 첫째 줄에 자연수 N을 연속된 소수의 합으로 나타낼 수 있는 경우의 수를 출력한다.

## 내 풀이
 우선 이 풀이는 느리다는 것과 그래서 pypy를 통해 통과했다는 것을 이야기 하고 시작하겠다. 만약 python으로 풀고 싶으면 소수를 저장하는 리스트를 만드는 다른 방법을 찾아보길 바란다. 물론 잡담 부분에 적긴 할 것인데 자세하겐 적지 않을 것이므로 힌트만 받고 직접 생각하든 찾아보길 바란다.

 이문제는
 1. N이하의 소수들이 정렬되어 저장된 리스트를 만든다.(하드코딩 하면 무조건 빠르지만... 이 리스트를 얼마나 시간적 효율을 챙길 수 있는지를 묻는 문제이므로 추천하지 않는다.)
 1. 해당 리스트를 앞에서 부터 하나씩 더하다가 N을 넘으면 앞에서부터 하나 빼고 N과 같으면 count를 증가하는 식으로 몇개가 같은지 확인한다.<br>
 예를 들어 [2,3,5,7,11,13,17]에 N=17이라 가정 했을때 count=0으로 하고 리스트에서 맨 앞에 하나를 뽑아준다.<br>
 그 후 처음 뽑은 2에다가 다음 원소인 3을 더해주고 5를 더해주고 7을 더해주는 식으로 하나씩 더해간다.
 이때 7까지 더하면 2+3+5+7 = 17로 N과 같아지므로 count를 1개 증가 시켜주고 다시 그 다음 수인 11을 더한다. <br>
 그러면 2+3+5+7+11=17+11=28이 되어 N보다 커지므로 처음에 더한 2를 3을 5를 이런식으로 빼가면서 N보다 작거나 같아질때까지 반복하는 식을 말한다.
 1. 1.과 2.과정을 반복하여 리스트의 모든 원소를 더하고 뺄때까지 반복한다.

 이런식으로 풀 수 있다.

## 구현([전체 코드 파일](/baekjoon/1644소수의연속합/c.py))
``` python
def pr(N:int)->list:
	L = [2,3,5,7,11]
	if N<12:
		return [i for i in L if i<=N]
	for n in range(13,N+1,2):
		if n%5==0:
			continue
		if n%12 in set([1,5,7,11]):
			flag = True
			for i in L:
				if i*i > n:
					break
				if n%i == 0:
					flag = False
					break
			if flag:
				L.append(n)
	return L

def A(N:int)->int:
	L = pr(N)
	s, e, count, tmp = 0, 0, 0, 0
	while True:
		if e<len(L):
			if tmp<N:
				tmp += L[e]
				e += 1
			else:
				if tmp==N:
					count += 1
				tmp -= L[s]
				s += 1
		else:
			if tmp>N:
				tmp -= L[s]
				s += 1
			else:
				if tmp == N:
					count += 1
				break
	return count
```

## 잡담
우선 내가 푼 방식은 숫자를 하나씩 확인해 가면서 소수이면 넣고 아니면 다음 숫자를 찾아가는 방식인데... 이게 소수인지 확인할때 그동안 만든 리스트를 이용하여 속도를 줄이고 나만의 비법?으로 줄인(비법이라고 해야하나.. 옛날에 소수인지 아닌지 판별하는 프로그램 성능 더 높여보고 싶어서 구글링 하다가 찾은? 그런 방법이다.)방식으로 소수 리스트를 만들었는데 이것저것 했다 해도 BigO로 따지면 O(NlogN)정도 될 것이다...

그런데 풀고 나서 다른사람들이 어떻게 풀었나 보는데 그냥 에라토스테네스의 체를 가져왔더라... 에라토스테네스의 체 배울때 가장 먼저 배우는 방법인데 왜 이걸 생각 못했는지 내 머리가 안타깝다... 뭐냐고 물어본다면 길이 N의 True가 들어간 리스트를 만들고 2배수 인덱스를 False 그 다음 3을... 이 이상 이야기 할 필요 있나? 아 내 옛날 프로그래머스에 푼 그 걸 보던 다른 사람들의 마음이 이런 마음이였나 싶다...
언젠가 한번 소개 하고 싶다 그 문제...