# 백준[11660](https://www.acmicpc.net/problem/16953)번
## 문제
 정수 A를 B로 바꾸려고 한다. 가능한 연산은 다음과 같은 두 가지이다.

 * 2를 곱한다.
 * 1을 수의 가장 오른쪽에 추가한다. 

 A를 B로 바꾸는데 필요한 연산의 최솟값을 구해보자.


## 입력
 첫째 줄에 A, B (1 ≤ A < B ≤ 10<sup>9</sup>)가 주어진다.

## 출력
 A를 B로 바꾸는데 필요한 연산의 최솟값에 1을 더한 값을 출력한다. 만들 수 없는 경우에는 -1을 출력한다.

## 내 풀이
 BFS문제이다.
 그냥 큐와 셋을 만들고 큐에는 A와 현재 연산횟수+1인 1을 묶어서 넣어주고 셋에는 A를 넣어준다.
 그 후 큐에서 하나를 꺼내어 B와 비교하고 같으면 연산횟수+1부분을 출력하고 다를경우 2A와 10A+1을 구하고 B와 비교 후 B보다 작은 수들을 셋포함되어 있지 않은 수를 각각 큐와 셋에 넣어주는데 큐는 꺼낸 수와 묶인 현재 연산횟수+1에 1을 더한 숫자와 묶어 넣어준다.
 이를 반복하다가 큐가 비어있으면 만들 수 없는 경우이므로 -1을 출력해 준다.

## 구현([전체 코드 파일](/baekjoon/16953A->B/c.py))
``` python
def A():
	s, e = list(map(int,input().strip().split()))
	Q = [{"v":s,"l":1}]
	S = set([s])
	while Q:
		tmp = Q.pop(0)
		if tmp["v"] == e:
			return tmp["l"]
		a,b = tmp["v"]*2, tmp["v"]*10+1
		if a<=e and a not in S:
			S.add(a)
			Q.append({"v":a, "l":tmp["l"]+1})
		if b<=e and b not in S:
			S.add(b)
			Q.append({"v":b, "l":tmp["l"]+1})
	return -1
```

## 잡담
 오랫동안 못풀다가 폴짝폴짝을 풀고 풀었는데 내 고정관념이 그 동안 얼마나 나를 옭아매어왔는지 알 수 있던 시간이였다. 허허...