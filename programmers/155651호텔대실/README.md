# Programmers[Lv 2 호텔 대실](https://school.programmers.co.kr/learn/courses/30/lessons/155651)
## 문제
호텔을 운영 중인 코니는 최소한의 객실만을 사용하여 예약 손님들을 받으려고 합니다. 한 번 사용한 객실은 퇴실 시간을 기준으로 10분간 청소를 하고 다음 손님들이 사용할 수 있습니다.
예약 시각이 문자열 형태로 담긴 2차원 배열 book_time이 매개변수로 주어질 때, 코니에게 필요한 최소 객실의 수를 return 하는 solution 함수를 완성해주세요.

## 제한사항 
* 1 ≤ book_time의 길이 ≤ 1,000
    * book_time[i]는 ["HH:MM", "HH:MM"]의 형태로 이루어진 배열입니다
        * [대실 시작 시각, 대실 종료 시각] 형태입니다.
    * 시각은 HH:MM 형태로 24시간 표기법을 따르며, "00:00" 부터 "23:59" 까지로 주어집니다.
        * 예약 시각이 자정을 넘어가는 경우는 없습니다.
        * 시작 시각은 항상 종료 시각보다 빠릅니다.

## 내 풀이
힙! 힙! 힙!!!!!  
힙을 이용하여 풀었다.  
우선 2개의 힙 테이블을 준비하고 하나는 모든 시간을 들어오는 시간을 기준으로 최소힙을 구현하게 하였고 하나는 사람이 있는 방들이다.  
뭐 그런것도 그렇지만 여기서 사용된 테크닉은 인아웃 시간을 하나로 묶는것, 10분뒤를 계산하는 것, 묶은 시간을 분할하는것이다!

### 시간 묶고 풀기
뭐 간단하다. 시간을 표현힐 떼 HH:MM식으로 하니 00:00&#126;23:59가 될 것이고 이를 ':'만 없에면 숫자로 표현이 되며 대소 관계는 그대로 유지되므로 0000&#126;2359까지의 숫자로 표현하면 된다.  
이 숫자들을 묶어서 관리하기 위해여 한쪽 시간(난 들어오는 시간으로 했다.)*10000에다가 나머지 시간을 더해주면 된다.

    예를 들어 10:00에 들어오고 12:00에 나간다 하면 10:00을 1000으로 바꾸고 12:00을 1200으로 바꾼뒤 1000*10000+1200을 하여 10001200의 숫자로 바꾼다.

이 숫자를 다시 풀려면 10000을 기억하면 된다.  
* 앞의 숫자는 묶은 숫자 / 10000
* 뒤의 숫자는 묶은 숫자 % 10000
이렇게 하면 된다 간단하다.

### 시간 더하기
사람이 나가고 10분을 정리 해야 다른사람이 들어올 수 있으니 앞의 시간 묶기에 나가는 시간 부분에다가 10분을 추가해야 한다.  
하지만 10을 그냥 더하면 60분 이상의 괴상한 시간이 나오고 이는 12:62(진짜는 13:02)<13:01이라는 오류를 범할 수 있다.  
그러므로 10분을 더한 값에 100으로 나눈 나머지가 60이상이 되면 해당 값을 처리를 해줘야 하는데

1. 페아노 공리를 읽어보라 x+1은 x의 다음 자연수가 된다.
1. x의 다음 자연수를 y라 했을 경우 x+1 = y가 성립된다.
1. x+1 = y의 양변에 10을 곱해주면 10*(x+1) = 10*x + 10 = 10*y가 되고 이는 10의 x배수인 어떤수에 10을 더하면 x의 그 다음 자연수의 10배가 된다.
1. 10*x + 10 = 10*y의 양변에 한자리 자연수 c를 더하면 10*x + 10 + c= 10*y + c이므로 10을 더해도 1의 자리수는 변하지 않는다.

를 통해 10을 더해도 1의 자리수는 그대로이므로 60이상이 되면 60을 빼줌으로 분을 정의할 수 있고 100을 더하여 한시간으 더 올라갔다는 것을 알려 줄 수 있다.  
물론 2시간 이상이 올라 갈 수 있는것 아니야 하는 사람은 없길 바란다. x+1을 했을때 자릿수 올림은 0&#126;1사이 자연수다. 즉 0 아니면 1이라 2시간 이상으로는 못올라간다. 당연히 없길 바란다...

### 그럼 정렬은?
사실 이 문제는 막 정렬할 필요가 없다 최소값!만 있으면 되기 떄문에 힙을 선택한거다. 최소힙은 언제나 루트가 최소값이기 때문이다.  
생각해보자 들어갈 사람을 위한 방은 언제나 가장 처음으로 나가는 사람의 시간+10분과 비교해서 그 시간에 맞으면 나간 사람방에 배정해주고 그걸 못하면 새 방을 준비하는 문제이기 때문에 그렇다.  
그러므로 최소값만 알면 되고 그걸 위해 최소힙형태로 구현한거다.

### 정리전 마지막으로 주의할 것
힙 테이블 하나는 들어오는 시간 기준으로 움직이고 하나는 잘 조절해서 해줘야 한다. 잘 조절하는건 들어오는 시간과 나가는 시간을 비교해야 하니까고  
들어오는 시간 기준으로 정렬하는 애는 사람들이 차례대로 찾아오게 하여 문제를 해결해야 하기 때문이다. 10시에 도착하여 10시에 방에 들어가기로 한 사람이 9시에 도착하여 9시에 방에 들어가는 사람보다 먼저 도착하여 10시에 방에 들어갔는데 9시 사람이 9시에 들어..? 말부터 이상하지 않나? 10시 다음이 어떻게 9시?

### 최종정리
1. 사람들이 오는 순서인 힙테이블과 방을 나타내는 힙테이블을 준비한다.
1. 사람들이 오는 순서의 힙테이블에 체크인,체크아웃시간+10을 묶어서 최소힙에 넣는다.(정렬 아니라 그냥 최소힙 모양으로 트리에 넣는다)  
이때 체크인 시간 기준으로 최소힙이 구현되도록 한다.(10000*체크인+체크아웃 형태로 묶었으면 따로 할 필요없이 그냥 넣으면 된다.)
1. 방을 의미하는 힙테이블을 하나 만들고 체크아웃 기준으로 최소힙이 구현되게 만든다.
1. 방의 루트의 체크아웃+10분 시간과 사람들이 오는 순서인 힙의 루트와 비교하여 새로운 방을 줄지(up함수) 기존 방을 줄지(down)을 선택하여 정한다.
1. 사람람들이 오는 순서인 힙을 pop하고 반복한다.
 
## 구현([전체 코드 파일](/programmers/155651%ED%98%B8%ED%85%94%EB%8C%80%EC%8B%A4/solution/))
``` c
int solution(char ***book, size_t r, size_t c){
	int timestamp[1001];
	int room[1001];
	size_t tsIdx, rIdx;
	tsIdx = rIdx = 0;
	for(int i=0; i!=r; i++){
		up(timestamp, &tsIdx, twoTime(book[i]), 1);
	}
	
	up(room, &rIdx, timestamp[1], 0);
	pop(timestamp, &tsIdx, 1);
	while(tsIdx){
		if(out(room[1])>in(timestamp[1])){
			up(room, &rIdx, timestamp[1], 0);
		}
		else{
			down(room, &rIdx, timestamp[1], 0);
		}
		pop(timestamp, &tsIdx, 1);
	}

	return rIdx;
}

void up(int *arr, size_t *size, int n, char roomIn){
	arr[++(*size)] = n;
	int idx = *size;
	while(idx>>1){
		if(roomIn){
			if(arr[idx]<arr[idx>>1]){
				arr[0] = arr[idx];
				arr[idx] = arr[idx>>1];
				arr[idx>>=1] = arr[0];
			}
			else{break;}
		}
		else{
			if(out(arr[idx])<out(arr[idx>>1])){
				arr[0] = arr[idx];
				arr[idx] = arr[idx>>1];
				arr[idx>>=1] = arr[0];
			}
			else{break;}
		}
	}
}

void down(int *arr, size_t *size, int n, char roomIn){
	arr[1] = n;
	int i = 1;
	while((i<<1)<=*size){
		if(roomIn){
			if((i<<1)+1<=*size){
				int child = arr[i<<1]<arr[(i<<1)+1]? i<<1: (i<<1)+1;
				if(arr[i]>arr[child]){
					arr[0] = arr[i];
					arr[i] = arr[child];
					arr[i=child] = arr[0];
				}
				else{break;}
			}
			else{
				if(arr[i]>arr[i<<1]){
					arr[0] = arr[i];
					arr[i] = arr[i<<1];
					arr[i<<=1] = arr[0];
				}
				else{break;}
			}
		}
		else{
			if((i<<1)+1<=*size){
				int child = out(arr[i<<1])<out(arr[(i<<1)+1])? i<<1: (i<<1)+1;
				if(out(arr[i])>out(arr[child])){
					arr[0] = arr[i];
					arr[i] = arr[child];
					arr[i=child] = arr[0];
				}
				else{break;}
			}
			else{
				if(out(arr[i])>out(arr[i<<1])){
					arr[0] = arr[i];
					arr[i] = arr[i<<1];
					arr[i<<=1] = arr[0];
				}
				else{break;}
			}
		}
	}
}

int twoTime(char **arr){
	return 10000*s2i(arr[0])+addTen(s2i(arr[1]));
}

int in(int t){
	return t/10000;
}

int out(int t){
	return t%10000;
}

int addTen(int t){
    t += 10;
	return t%100<60? t: t-60+100;
}
```

## 잡담
아 중간에 C++ 로 갈아타서 red-black tree인 set써서 편하게 갈까 고민 많이 했다... 왜냐? 나머지는 다 잘 구현했는데 실수로 60분 넘었을때 대처를 잘못함.. ㅎㅎ...... 그거 몰라서 엉뚱한거 찾다가 운좋게......... 아 맨날 이런거 틀려....  
생각해보면 그거 틀렸으면 set써도 틀리네 ㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋ  
그리고 보면 기수정렬 응용한 풀이들 보이는데... 빠른..? 뭐 시간 내에는 되긴 하겠네 제한조건이 너무 짧으니 아니 나보다 빠른건...가??? ㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋ 내가 생각이 너무 많은건가... 아님... 아 진짜 모르겠다.... ㅋㅋㅋㅋㅋㅋㅋㅋㅋ
