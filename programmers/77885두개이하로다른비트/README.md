# Programmers[Lv 0_이름](https://programmers.co.kr/learn/courses/30/lessons/77885)
## 문제
 양의 정수 x에 대한 함수 f(x)를 다음과 같이 정의합니다.

    x보다 크고 x와 비트가 1~2개 다른 수들 중에서 제일 작은 수

예를 들어,

    f(2) = 3 입니다. 다음 표와 같이 2보다 큰 수들 중에서 비트가 다른 지점이 2개 이하이면서 제일 작은 수가 3이기 때문입니다.

수 	비트 	다른 비트의 개수
2 	000...0010 	
3 	000...0011 	1

    f(7) = 11 입니다. 다음 표와 같이 7보다 큰 수들 중에서 비트가 다른 지점이 2개 이하이면서 제일 작은 수가 11이기 때문입니다.

수 	비트 	다른 비트의 개수
7 	000...0111 	
8 	000...1000 	4
9 	000...1001 	3
10 	000...1010 	3
11 	000...1011 	2

정수들이 담긴 배열 numbers가 매개변수로 주어집니다. numbers의 모든 수들에 대하여 각 수의 f 값을 배열에 차례대로 담아 return 하도록 solution 함수를 완성해주세요.

## 제한사항 

    1 ≤ numbers의 길이 ≤ 100,000
    0 ≤ numbers의 모든 수 ≤ 1015


## 내 풀이
 이 문제의 핵심은 0을 찾는 건데 그 0이 1의자리 비트부터 시작해서 연속된 1이 끝나고 나오는 첫 0이 시작되는 위치를 찾는것이 핵심이다.  
 예를들어3(0000 0111)을 보면 우리가 필요한 숫자는 3보다 1큰 숫자이므로 여기다 우선 1을 더하고 생각해보면 4(0000 1000)이 되는데여기서 4와 3을 xor해보면 딱 0이 있는 위치까지 1로 이루어 진다(0000 1111) 여기서 좀더 보면 4에서 xor결과값인 4를 4로 나눈 값인 1(0000 0001)을 더하면 신기하게 3보다 크면서 비트가 2개 이하로 다른 숫자가 나온다.  
 즉 1을 더하게 되면 연속된 1들은 전부 0이되고 맨 첫 0이 1이 된 숫자가 되고 그 두 숫자의 xor관계가 얼마나 바뀌었는지 알려주게 된다. 그래서 우린 2개 이하도 달라야 하므로 쉬프트를 2해줌으로서 조건에 맞춰 더해줌으로 답을 도출 할 수 있다.

## 구현([전체 코드 파일](/programmers/77885%EB%91%90%EA%B0%9C%EC%9D%B4%ED%95%98%EB%A1%9C%EB%8B%A4%EB%A5%B8%EB%B9%84%ED%8A%B8/c.java))
``` java
class Solution {
    public long[] solution(long[] numbers) {
        long[] answer = numbers.clone();
        for(int i = 0; i< answer.length; i++){
            answer[i]++;
            answer[i] += (answer[i]^numbers[i])>>>2;
        }
        return answer;
    }
}
```

## 잡담
사실 뭐가 중요하다 이런건 없고 그냥 노가다로 1~30 그리고 어 싶었을때 막 1001000 해보고 이렇게 찾았다... 그렇게 해서 푸니까 다른 사람들이 풀이 해주는 기적이.....