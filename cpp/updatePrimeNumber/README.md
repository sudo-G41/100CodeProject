# 소수판별 코드
소수판별은 기본적인 제어문 교육용 코드지만 가끔씩 쓰이는 코드이다.
## 기존 코드
가장 기본적인 코드로
```cpp
bool prim(int num){
    for(int i=2; i!=num; i++){
        if(!(num%i)){return false;}
    }
    return true;
}
```
아주 기본적이고 기본적인 코드지만 알 사람들은 다 알거다 최악의 코드라 해도 좋다는걸...  
설명하자면

소수의 특징이 1과 자기 자신만을 약수로 가지는 수를 소수라 한다.(1은 제외 이유는 다른 곳에서 찾아봐 주세요!)

그리고 어떠한 자연수를 $N$이라 할 때 $N$ = $a$ x $b$ 일 때 
$a$와 $b$는 $N$의 약수이고 이러한 점에 의해 모든 약수는 짝을 가지고 있다.($N$이 제곱수일 때 루트 $N$은 자기자신이 짝이므로 예외라 볼 수 있지만 짝이 있다고 볼 수 있잔ㅇ.... 크흠..)

그리고 $a,b$는 루트 $N$을 기준으로 대칭($a$<루트 $N$이면 $b$>$N$이라는 이야기다.)을 이루기 때문에 루트 $N$이하의 자연수중 약수가 존재하지 아니하면 루트 $N$이상의 자연수에도 대칭되는 수가 없어 약수가 존재 할 수 없다. (좀더 수학적인건 수학과한태 물어봐주세요...)

## 조금 더 업그레이드 해봅시다.
이 장황한 설명을 왜 했냐? 위의 코드중 i!=num;을 i*i!=num까지(i != 루트num 의 양변을 제곱한 것 이라 같다고 볼 수 있다.)로 변경해도 된다는 이야기고 이러면 속도가 O($N$)에서 O($log N$)으로 엄청 줄어든다.
```cpp
bool prim(int num){
    for(int i=2; i!=num; i++){
        if(!(num%i)){return false;}
    }
    return true;
}
```

## 여기서 더 업그레이드가 된다고?
여러분 짝수의 정의가 무엇인지 아시나요..?
짝수는 $N$ = $2k$로 표현이 된다.
즉 어떠한 수의 2배는 전부 짝수란 이야기이다.
그러므로 짝수는 모두 2를 약수로 가지기 때문에 2를 제외한 모든 짝수는 1과 자기자신 그리고 2를 약수로 가지고 있어 소수의 조건을 만족할 수 없다..(2는 1과 2 이렇게 약수를 가지는데 2가 자기자신이라 소수의 조건에 맞다)

그러므로 num이 짝수일 경우 그냥 생략이 가능하다는 것!

```cpp
bool prim(int num){
    if(num%2 || num == 2){
        for(int i=3; i!=num; i++){
            if(!(num%i)){return false;}
        }
        return true;
    }
    return false;
}
```

## 위에거 잘 생각해보면
짝수는(2제외)는 소수가 될 수 없고, 어떠한 수의 약수는 소수의 조합으로 만들어지는 숫자이다.  
여기서 짝수의 곱에대해 조금 생각해보면 $2a$ x $b$ = $2ab$ = $2(ab)$이므로 짝수와 어떠한 수를 곱하면 짝수가 되는 특징이 있으므로 약수 탐색에서 짝수는 비교해볼 필요가 없다 즉 위 코드의 i는 짝수일 필요가 없으므로 이렇게 수정이 가능하다.

```cpp
bool prim(int num){
    if(num%2 || num==2){
        //i++에서 i+=2로 짝수는 건너뛰기!
        for(int i=3; i!=num; i+=2){
            if(!(num%i)){return false;}
        }
        return true;
    }
    return false;
}
```
## 여기까지가 사람들이 알고있는 소수판별 코드지만...
나는 여기서 더 업그레이드 할 것 이다. 일단 원리는 설명 할 것이지만 나도 모르는게 몇개 있어서 참고할거면 직접 찾아보시는걸....

우선 코드 먼저 올린다.
```cpp
bool prime(int i){
	if(i<13){
		switch(i){
			case 2: case 3: case 5:
			case 7:	case 11:
				return true;
			default:
				return false;
		}
	}
	switch(i%10){
		case 1: case 3:
		case 7: case 9:
			switch(i%12){
				case 1: case 5:
				case 7: case 11:
					int n = 3;
					while(i>n*n){
						if(!(i%n)){return false;}
						n+=2;
					}
					return i != (n*n);
			}
	}
	return false;
}
```
우선
```cpp
if(i<13){
    switch(i){
        case 2: case 3: case 5:
        case 7:	case 11:
            return true;
        default:
            return false;
    }
}
```
을 보면 13미만의 수는 다이렉트로 소수인 수와 아닌 수를 직접적으로 구분 시킨다. 이유는 아래 판별법이 13미만의 수에는 먹통이 되는 수가 있고 소수가 충분히 적은 갯수를 가지고 있으므로 직접 매핑으로 통해 걸러내는 것이다.
여기서 걸러지는건 O(1)의 속도를 가지므로 최고 속도는 O(1)이다.

그 다음으로 
```cpp
switch(i%10){
    case 1: case 3:
    case 7: case 9:
        ...//무언가 코드...
}
return false;
```
인데 i의 1의 자리수가 1,3,7,9이면 짝수가 아닌 수이므로 그 외의 수는 짝수라 소수가 안된다.  
코드를 잘 읽어보고 있는 분은 의문이 하나 생길 것이다. "일의자리 수 5인 수도 짝수냐!!!"라고 물론 5이면 홀수지만 여기서 5의 배수의 특징이 등장한다! 5의 배수는 일으자리수가 5와 0을 가지는 특징이 있어서(왜 그렇게 되냐 궁금하면 수학교육과분들에게 물어봐주세요...)결국 일의 자리수가 5면 약수가 될 수 없다(여기서 13미만이 걸린다..)
이걸 이용하여 짝수와 5의 배수는 걸러냈다.
그럼 저 무언가 코드를 한번 보자
```cpp
switch(i%12){
    case 1: case 5:
    case 7: case 11:
    ///여기부터
        int n = 3;
        while(i>n*n){
            if(!(i%n)){return false;}
            n+=2;
        }
        return i != (n*n);
        ///여기까지
}
```
중간에 코드는 기존 소수 판별법을 조금 변형한거여서 차이는 없다 가져다 써도 된다.
그럼 다른점은 뭐냐? 스위치문으로 $N$을 12로 나눈 약수중 1,5,7,11이 아닌 수는 소수가 아니라고 걸러낸다.
이유가 뭐냐고? 앞서 이야기한것 처럼 나도 모른다... 뭐 제타함수가 어쩌고 하는데 내 머리론 이해 못했다... 여러분 죄송합니다.... 근데 여기 걸러지는 숫자가 은근 많다.

## 뭔가 코드가 길어졌으니 중간 코드 가면 오히려 더 걸리는거 아니야?
나도 뭔가 몬가 의심은 드는데 프로그래머스에서 테스트 했을때 더 오래 걸린적이 없다.... 왜지???왜 그런거야???? 물론 걸러내는 체가 많기 때문에 거기에 걸리면 빠른건 맞지만 안그런 애들은 시간 걸려야 하는데 왜지?? 나도 모르것다...

## 사실...
가장 베스트는 이 코드이다. 이거보다 빠르면 그건 말이 안된다...(귀찮으니 파이선으로...)
```python
def prime(num):
    primes = set([세상의 모든 소수])
    return num in primes
```
말이 안되는 코드지만 진짜 빠르다...  
좀 느리지만 그래도 현실적인 코드는(그래도 비현실적이다...)
```python
def prime(num):
    primes = [num**0.5이하의 소수들]
    for i in primes:
        if num%i == 0:
            return False
    return True
```
이거 진짜 빠르다... $log N$보다 거의 빠르다...
그래서 에라토스테네스의 체를 잘 사용하면 은근 빠르다... 내 코드가 빠르긴 하지만 상황에 따라서 에라토스테네스의 체가 더 빠르기도 하고 느리기도 하다... 그럼 이만...!!!