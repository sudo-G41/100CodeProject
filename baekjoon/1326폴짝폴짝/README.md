# 백준[11660](https://www.acmicpc.net/problem/1326)번
## 문제
 개구리가 일렬로 놓여 있는 징검다리 사이를 폴짝폴짝 뛰어다니고 있다. 징검다리에는 숫자가 각각 쓰여 있는데, 이 개구리는 매우 특이한 개구리여서 어떤 징검다리에서 점프를 할 때는 그 징검다리에 쓰여 있는 수의 배수만큼 떨어져 있는 곳으로만 갈 수 있다.
 
 이 개구리는 a번째 징검다리에서 b번째 징검다리까지 가려고 한다. 이 개구리가 a번째 징검다리에서 시작하여 최소 몇 번 점프를 하여 b번째 징검다리까지 갈 수 있는지를 알아보는 프로그램을 작성하시오.

## 입력
 첫째 줄에 징검다리의 개수 N(1≤N≤10,000)이 주어지고, 이어서 각 징검다리에 쓰여 있는 N개의 정수가 주어진다. 그 다음 줄에는 N보다 작거나 같은 자연수 a, b가 주어지는 데, 이는 개구리가 a번 징검다리에서 시작하여 b번 징검다리에 가고 싶다는 뜻이다. 징검다리에 쓰여있는 정수는 10,000보다 작거나 같은 자연수이다.

## 출력
 첫째 줄에 개구리가 a번 징검다리에서 b번 징검다리로 최소 몇 번 점프하여 갈 수 있는 지를 출력하시오. a에서 b로 갈 수 없는 경우에는 -1을 출력한다.

## 내 풀이
 우선 개구리는 a에서 b로 갈 수 있는지 갈수 있다면 몇번 점프 하는지 묻는 문제로 입력을 잘 보면 a<b라는 내용은 없다.
 그러므로 오른쪽으로도 왼쪽으로도 움직일 수 있는 개구리를 위해 전체를 확인하는데 무작정 하면 O(N<sup>2</sup>)의 시간이 필요하므로 시간을 초과하게 된다.

 그러므로 몇가지 트릭을 통해 시간을 줄이는데

 1. 이미 뛰었던 곳은 확인하지 않는다.
 1. 현재 위치에 있는 수의 배수만 뛸 수 있으므로 배수 위치만 확인한다.
 1. (도착 위치 - 현재 위치) mod 현재 징검다리에 적힌 수가 0이면 현재 위치에서 도착 할 수 있다는 이야기다.
 1. DFS로 탐)색을 할 경우 모든 상황을 확인하고 비교해야 최소 점프 수를 알수 있지만 BFS는 첫 도착이 최소 점프이므로 BFS가 좀더 시간적으로 유리하다. 그러므로 다음 뛸 위치는 queue를 통해 찾아 가는 것이 좋다.(싫으면 DFS로 해도 1.번만 잘 지키면 시간내에 확인은 가능하긴 할 것이다... 아마...)

 이러한 조건을 잘 생각하면서 풀어보면

 우선은 1번 조건을 위해 queue와 set을 준비하고 처음 위치를 저장하여 queue에는 다음에 뛸 위치와 다음 점프가 몇번째 점프인지를, set은 한번이라도 방문한 위치에 다시 왔을때는 검사하지 않도록 한다.
 
 그 후 queue에서 하나 꺼내고 b에 도착 가능한지 확인하고 도착 가능하면 몇번째 점프인지를 리턴하고 아니면 다음 점프에 도착하는 위치를 구하는데 이때 있는 징검다리의 수가 n이라 하면 n을 더하거나 빼면서 이미 방문한적 있는지 확인 후 방문한적 없는 곳들만 추려서 구해주면 된다.

 하지만 나는 징검다리의 길이 나누기 n을 통해 점프해서 도착할 수 있는 왼쪽 끝을 찾고 거기서부터 i*n을 통해 계산하였다... 어느쪽이든 같으므로 마음에 드는 방법으로 하면 된다.(그냥 더했다가 다시 돌아와 빼가는게 싫어서 이렇게 했다...)

 그 다음 도착 위치를 구한 것들을 queue와 set에 넣어준다. 이때 queue에는 현재 점프+1을 같이 묶어서 넣어주어 도착시 몇번째 점프인지 알려준다.

 이를 queue에서 꺼내고 확인하고 점프위치 구하고 넣고를 반복하면서 queue가 비거나 도착할때까지 반복해 준다. 이때 queue가 비었다는 이야기는 b에 도착할 방법이 없다는 이야기이므로 이때는 -1을 출력하여 도착하지 못한다는 것을 알려준다.

## 구현([전체 코드 파일](/baekjoon/1326폴짝폴짝.c.py))
``` python
from sys import stdin
input = stdin.readline

N = int(input().strip())
L = [0]
L.extend(list(map(int,input().strip().split())))
a,b = list(map(int,input().strip().split()))

def A(L:list,a:int,b:int)->int:
	if a==b:
		return 0
	q=[{"q":[a],"level":1}]
	size = len(L)-1
	idxSet = set([0])
	while q:
		al = q.pop(0)
		for aa in al["q"]:
			if aa>size:
				continue
			if isA(L,aa,b):
				return al["level"]
			else:
				tmp = aa%L[aa]
				nextmp = size//L[aa]
				qwer = [tmp+i*L[aa] for i in range(nextmp+1) if tmp+i*L[aa] not in idxSet]
				if qwer:
					q.append({"q":qwer,"level":al["level"]+1})
					idxSet.update(qwer)
	return -1
	
def isA(L:list,a:int,b:int)->bool:
	return (b-a)%L[a] == 0

print(A(L,a,b))
```

## 잡담
 그래프 탐색 문제인데 평소 같으면 익숙한 DFS로 풀었겠지만 이 문제는 BFS를 써야지만 풀리는 문제라 오랜만에 BFS를 다시 짜면서 그 동안 재귀에 내가 너무 묶여 있었구나라는 것을 꺠달았지만... 또 잊어버릴까봐 무섭다...<br>
 그리고 최근 문제만 풀어놓고 git에 올리질 않아서 좀 쌓였다...<br>
 아니 문제가 안풀리는게 있어서 한숨 쉬면서 좀더 쉬운거 풀다 보니 멘탈이 갈려서 못올리겠더라...<br>
 마듀 다이아찍고 다시 멘탈 잡아서 올리는 중이다.. ㅎㅎ...<br>
 아니 이거 풀때도 왜 안되... 이러고 있었는데 같이 푸는 친구가 "아 이거 뒤로(왼쪽으로)뛸 수 있어요."라고 말 안 해줬으면 나 못풀었을지도... 멘탈 더 갈려서 코딩에 손 놓았을지도... 하... 그냥 그랬던 스토리 ㅎㅎ..